##问题

---

1. 总结几种 socket 粘包的解包方式：fix length/delimiter based/length field based frame decoder。尝试举例其应用。

* 什么是粘包和半包

> 当发送两条消息时，比如发送了ABC和DEF，但另一端接收到的却是ABCD，这种一次性读取了两条数据的情况就叫做粘包。

> 当发送的消息是ABC时，另一端却接收到的是AB和C两条信息，这种情况就叫做半包

* 为什么会有粘包和半包？

> TCP是面向连接的传输协议，传输的数据是以流的形式，而流数据是没有明确的开始结尾边界，所以TCP也没办法判断哪一段流属于一个消息。

* 粘包的主要原因：

>- 发送方每次写入数据 < 套接字（Socket）缓冲区大小；
>- 接收方读取套接字（Socket）缓冲区数据不够及时。

* 半包的主要原因：

>- 发送方每次写入数据 > 套接字（Socket）缓冲区大小；
>- 发送的数据大于协议的 MTU (Maximum Transmission Unit，最大传输单元)，因此必须拆包。

* fix length

> 定长型包，每个包固定大小，主要适用单一类型的包

> 优点：解决了粘包问题

> 缺点：
>- 包内容如果常常小于定长时，会有浪费;
>- 包内容如果大于定长时，会出现半包的问题；
>- 包长度要改动时不灵活，服务端和客户端需要同时调整;

> encode：通常采用左对齐右补0方式填满包

> decode：读取固定大小，一次没有读到足够大小内容，就继续读，直到累加到内容长度等于固定大小为一包

* delimiter based

> 变长型包，每个包使用特殊符号做为结束符，比如客户端发送过来的数据，每次以\n结束，服务器每接受到一个 \n 就以此作为一个请求.

> 优点：基本可以按照实际大小进行传输

> 缺点：
>- 选用的特殊符号不能在Body中出现，否则会导致解包与封包不一至;
>- 如果数据量过大，查找定界符会消耗一些性能

> encode：要发送内容后加上包分隔符

> decode: 一直读取到分隔符为一包
 
* length field based frame decoder

> 变长型包，固定位+变长位，固定位：一般包含包标示符，包长度，变长的要传递内容

> 优点：灵活，组包没有限制，适用于传递二进制包内容

> 缺点：每个包都会有加上固定位，增多了要传递的内容;

> encode：包标示符(1 Byte) + 传递内容的长度(2 Byte) + 传递内容

> decode: 
> - 先读取固定长度3byte = 包标示符(1 Byte) + 传递内容的长度(2 Byte);
> - 取byte[0]进行比较，是否为已知标识；
> - 取byte[1:3]转化为数字，得到传递内容长度;
> - 按传递内容长度读取内容，一次没有读到足够大小内容，就继续读，直到累加读到的内容长度等于传递内容长度

> 

2. 实现一个从 socket connection 中解码出 goim 协议的解码器。